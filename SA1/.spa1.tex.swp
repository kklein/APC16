%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{enumerate} % used for enumerate args
\usepackage{multicol} % columns

\usepackage{pgf} 
\usepackage{tikz}
%\usepackage{forest} % treees :D
%\usetikzlibrary{arrows,automata} %for FSM

% Custom commands
\DeclareMathOperator{\Kl}{Kl} %Klassen von Zust√§nden

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
% Shamelessly copied from http://tex.stackexchange.com/questions/43008/absolute-value-symbols
\DeclarePairedDelimiter\abs{\lvert}{\rvert} % nice |x|
\DeclarePairedDelimiter\norm{\lVert}{\rVert} % nice ||x||
% Swap the definition of \abs* and \norm*, so that \abs
% and \norm resizes the size of the brackets, and the 
% starred version does not.
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother


% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
%\chead{\hmwkClass\ (\hmwkClassInstructor\): \hmwkTitle} % Top center head
%\rhead{\firstxmark} % Top right header
\rhead{}
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Seite\ \thepage\ von\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

%\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
%\lstloadlanguages{Pascal} % Load Pascal syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/%contrib/listings/listings.pdf
%\lstset{language=Perl, % Use Pascal in this example
%        frame=single, % Single frame around code
%        basicstyle=\small\ttfamily, % Use small true type font
%        keywordstyle=[1]\color{Blue}\bf, % Pascal functions bold and blue
%        keywordstyle=[2]\color{Purple}, % Pascal function arguments purple
%        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
%        identifierstyle=, % Nothing special about identifiers                                         
%        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
%        stringstyle=\color{Purple}, % Strings are purple
%        showstringspaces=false, % Don't put marks in string spaces
%        tabsize=5, % 5 spaces per tab
%        %
%        % Put standard Pascal functions not included in the default language here
%        morekeywords={rand},
%        %
%        % Put Pascal function parameters here
%        morekeywords=[2]{on, off, interp},
%        %
%        % Put user defined functions here
%        morekeywords=[3]{test},
%        %
%        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
%        numbers=left, % Line numbers on left
%        firstnumber=1, % Line numbers start with line 1
%        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
%        stepnumber=5 % Line numbers go in steps of 5
%}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .p), the second parameter is the caption
\newcommand{\pascalscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.p}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
%\newcommand{\enterProblemHeader}[1]{
%\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
%\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
%}

% Header and footer for when a page split occurs between problem environments
%\newcommand{\exitProblemHeader}[1]{
%\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
%\nobreak\extramarks{#1}{}\nobreak
%}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Exercise \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
%\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
%\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
%\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
%\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Special Assignment 1} % Assignment title
\newcommand{\hmwkDueDate}{20\ October\ 2015} % Due date
\newcommand{\hmwkClass}{Algorithms, Probability and Computing} % Course/class
\newcommand{\hmwkClassInstructor}{Prof. Steger, Prof. Holenstein, Prof. Welzl} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Kevin Klein} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor}
\vspace{3in}
}}
\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\addtocounter{homeworkProblemCounter}{0}
\newpage
%\tableofcontents
%\newpage

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
Let $P$ be the input set of points with $|P| = n$, with general position.

\begin{enumerate}[(1)]
\item - \(\mathcal{O}(n \cdot log(n)) \) \\
	Compute the Convex Hull of the set $P$. Runtime boundaries and correctnes can be guaranteed by using, for instance, Graham's algorithm.
\item - \(\mathcal{O}(n \cdot log(n)) \) \\
	Compute the Voronoi diagram of the set $P$. Runtime boundaries and correctnes can be guaranteed by using, for instance, Fortune's algorithm. For every vertex in the Voronoi diagram, which are  \(\mathcal{O}(n) \) many [2], we query whether the vertex is inside of the Convex Hull. If it is, we add the vertex to the queue $Q$. After a one-time prepocessing of \(\mathcal{O}(n) \) time, every query only takes \(\mathcal{O}(log(n)) \) time [0].
\item - \(\mathcal{O}(n \cdot log(n)) \) \\
	Determine all intersections of the edges of the Voronoi diagram with the convex hull. Add every intersection to the queue $Q$, while saving a reference from the intersection point to the neighbouring points from the initial graph, which is feasible according to the given representation of the Voronoi diagram. A single intersection can be determined within \(\mathcal{O}(log(n))\) time. [1] There are only \(\mathcal{O}(n)\) edges in the Voronoi diagram [2], therefore we query intersections \(\mathcal{O}(n)\) many times. This yields an overall runtime of \(\mathcal{O}(n \cdot log(n)) \).
\item - \(\mathcal{O}(n) \) \\
	Iterate over all items in the queue. For each, check what the minimal distance to its closest point is. Save the maximum of the minimum distances to the neighbouring points, as well as the point where this distances is associated with.
\item - \(\mathcal{O}(1) \) \\
	Return this point associated with the maximum value.
\end{enumerate}

\emph{Soundness} \\
If an point $c$ is returned by the algorithm, it is either a vertex of the Voronoi diagram inside the Convex Hull or an intersection of a Voronoi diagram edge and the Convex Hull, i.e. a point lying on the relative interior of a segment of the convex hull.
\begin{enumerate} [a)]
\item $c$ is vertex of Voronoi diagram \\
	By the definition of step 2, we make sure that the vertex lies inside of the Convex Hull. $c \in conv(P)$ follows directly. The radius is adapted to the minimum of the distances to the neighbouring points of $c$, i.e. no point can be closer to $c$ than the radius. Therefore $int(C) \cap P = \emptyset $.
\item $c$ is intersection of Voronoi diagram and Convex Hull \\
	As $c$ is on the Convex Hull, $c \in conv(P)$ follows trivially. As described in step 3, when adding this point to the queue, we can determine its nearest points of $P$ as the Voronoi diagram which points are closest to the edge, on which $c$ is lying. Therefore we can determine minimum of the distances to those points and use it as radius. It follows from the correctness of the Voronoi diagram representation, that no point can be closer to $c$ than the considered distance. Therefore $int(c) \cap P = \emptyset$. 
\end{enumerate}
\emph{Completeness} \\
A point $p$ we did not consider as a possible solution is either lying inside the Voronoi cells or on an enge of the Voronoi diagram, not intersection the Convex Hull.
\begin{enumerate}[a)]
\item $p$ lies inside of a Voronoi cell \\
	According to the definition of the Voronoi diagram, $p$ is closer to a point of $P$ than all the neighbouring vertices of the Voronoi diagram. Furthermore, those vertices are not closer to any other point of $P$ either, as they are defined to be equidistant to neighbouring points. Hence, no such point could yield a better solution.
\item $p$ lies on an enge of the Voronoi diagram, not intersection the Convex Hull \\
	
\end{enumerate}
[0] APC script, Chapter 2.1 Point/Line Relative to a Convex Polygon, paragraph 'Inside/On/Outside a Cnvex Polygon', p. 39  
[1] APC script, Chapter 2.1 Point/Line Relative to a Convex Polygon, paragraph 'A Line Hitting a Convex Polygon', p. 40  
[2] APC script, Chapter 2.3 Planar Point Location - More exmaples, paragrahp 'Closest Point in the Plane - the Post offce Problem', p.55
\end{homeworkProblem}
%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\end{homeworkProblem}

%----------------------------------------------------------------------------------------
%	PROBLEM 3
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
\begin{enumerate}[(a)]
	\item 			% (a)
		\( a_0 = 7, a_1 = 1 + 2 * a_0 = 15 \\
		\forall n \geq 2: \)
		\begin{align}
		 a_n &= 1 + 2 \cdot \sum_{i=1}^{n} a_{i-1} \\
		 a_{n-1} &= 1 + 2 \cdot \sum_{i=1}^{n} a_{i-1} \\
		\Rightarrow a_n - a_{n-1} &= 1 + 2 \cdot \sum_{i=1}^{n} a_{i-1} - ( 1 + 2 \cdot \sum_{i=1}^{n} a_{i-1} ) = 2 \cdot a_{n-1}\\
		\Rightarrow a_n & = 3 \cdot a_{n-1} \\
		&= \dots \\
 		&= 3 ^ {n-1} \cdot a_1 \\
		&= 3^{n-1} \cdot 15 \\
		\end{align}
	\item 			% (b)
		\( L_n := length\ of\ a\ central\ path\ in\ a\ BST\ of\ size\ n\ nodes\ \\
		l_n := \mathbb{E}(L_n) \\
		l_0 = 0, l_1 = 1, l_2 = 1/2 \cdot 2 + 1/2 \cdot 1 = 3/2\\
		\forall n \geq 3:\)
		\begin {align}
			l_n &= \sum_{i=1}^{n} ( \mathbb{E}[L_n | root = i] \cdot \Pr[root=i] ) \\
			&=  \sum_{i=1}^{n} ( \mathbb{E}[L_n | root = i] \cdot 1/n ) \\
  			&=  1/n \cdot \sum_{i=1}^{n} ( \mathbb{E}[L_n | root = i]) \\
    			&=  1/n \cdot \sum_{i=1}^{n} ( \mathbb{E}[L_{i-1}] +1) \\
 			&=  1 + 1/n \cdot \sum_{i=1}^{n} (l_{i-1}) \\
		\end{align}
		Furthermore, \( l_{n-1} = 1/n \cdot \sum_{i=1}^{n-1} (l_{i-1}) \)
 		\begin {align}
		  	n \cdot l_n - (n-1) \cdot  l_{n-1} &= n +  \sum_{i=1}^{n} (l_{i-1}) - ((n-1) +  \sum_{i=1}^{n-1} (l_{i-1}) \\
			&= 1 + l_{n-1} \\
			\Rightarrow n \cdot l_n &= 1 + n \cdot l_{n-1} \\
			\Rightarrow l_n &= 1/n +  l_{n-1} \\
			&= 1/n +  1/(n-1) + \dots + l_3 + l_2 \\
 			&= 1/n +  1/(n-1) + \dots + l_3 + 3/2 \\
  			&= 1/n +  1/(n-1) + \dots + l_3 + 1/2 + 1 \\
  			&= H_n \\
 		\end{align}
		We see that this also holds for \(n=2\) and \(n=1\) and therefore: \( \forall n \in \mathbb{N} - \{0\}. \)
	\item  			% (c)
		\( P_0^{(1)} = P_1^{(1)} = P_2^{(1)} = 0, P_3^{(1)} = 1/3, P_4^{(1)} = 1/4 \cdot 1/3 = 1/12 \\ 	
		\forall n \geq 5: \)
		\begin{align}
			P_n^{(1)} &= \sum_{i=1}^n (( P_n^{(1)} | root=i) \cdot \Pr[root=i]) \\
			&= \sum_{i=1}^n (( P_n^{(1)} | root=i) \cdot 1/n \\
			&= 1/n \cdot \sum_{i=1}^n (( P_n^{(1)} | root=i)   \\
			&= 1/n \cdot \sum_{i=1}^n P_{i-1}^{(1)}   \\
		\end{align}
		Furthermore, \( P_{n-1}^{(1)} =  1/(n-1) \cdot \sum_{i=1}^{n-1} (( P_{i-1}^{(1)} | root=i) \)
		\begin{align}
			\Rightarrow n \cdot P_n^{(1)} - (n-1) \cdot P_{n-1}^{(1)} &= \sum_{i=1}^n P_{i-1}^{(1)} - ( \sum_{i=1}^{n-1} P_{i-1}^{(1)} ) \\
			&= P_{n-1}^{(1)} \\
			\Rightarrow n \cdot P_n^{(1)} &= n \cdot P_{n-1}^{(1)} \\
			\Rightarrow P_n^{(1)} &=  P_{n-1}^{(1)} \\
			&=  P_{n-2}^{(1)} = \dots =  P_{4}^{(1)} \\
			&= 1/12
		\end{align}
		We see that this also holds for \(n=4\) and therefore: \( \forall n \in \mathbb{N}, n \geq 4. \)
	\item 			% (d)
\end{enumerate}
\end{homeworkProblem}

%----------------------------------------------------------------------------------------
%	PROBLEM 4
%----------------------------------------------------------------------------------------

\begin{homeworkProblem}
	\begin{enumerate}[(a)]
	\item %(a)
		Let $S = \{1,\dots, n \} $ be the set of all keys. Let $\Pr_S$ be the probability distribution on $\mathbb{D}_{S}$. For all $v \in V$, $w(v)$ denotes the number of keys in the subtree rooted at $v$. \\
		We define $\widetilde{w} (v)$ followingly: \\
		\[\widetilde{w} (v) = 
			\begin{cases} 
      		1 & w(v) \leq 2 \\
      		{w(v) \choose 2} & otherwise
   			\end{cases}
		\]
		Let $t \in_{u.a.r.} \mathbb{D}_{S}$. \\
		Accordingly, the probability of a tree with nodes $v \in V$ is the following: \\
		\[ \Pr_S[t] = \prod_{v\in V} \frac{1}{\widetilde{w} (v)} \] \\
		Let's observe the different cases to confirm this hypothesis. \\
		$n = 0:$ \\
		$t = \lambda \Rightarrow \Pr_S [t] = 1$ \\
		$n = 1:$ \\
		$t$ is the tree with a single node and a single key $k \in n$ it its root. $\Rightarrow \Pr_S [t] = 1$ \\
		$n = 2:$ \\
		$t$ is the tree with a single node and the keys $i,j \in n$ it its root. $\Rightarrow \Pr_S [t] = 1$ \\
		$n \geq 3:$ \\
		$t$ has a root with keys $i,j \in n, i < j$. Furthermore, $t$ has up to three subtrees $t_l, t_m, t_r$. 
		\begin{align}
			\Pr_S [t] &= Pr_S [root = \{i,j\}] \cdot \Pr_S [t_l] \cdot \Pr_S [t_m] \cdot \Pr_S [t_r] \\
			&= \frac{1}{{w(v) \choose 2}} \cdot \Pr_S [t_l] \cdot \Pr_S [t_m] \cdot \Pr_S [t_r] \\
			&= \frac{1}{\widetilde{w} (v)} \cdot \Pr_S [t_l] \cdot \Pr_S [t_m] \cdot \Pr_S [t_r] \\
		\end{align}
		Analogously[3], 'we can conclude that the values suggested in the assertion of the observation satisfy the recurrence'. 
		[3] APC script, Chapter 1.1 Definition, Lemma 1.1, p.4.
		\item %(b)
		In order to determine $m_n$ and $M_n$ we have a look at the 'best' and 'worst case' of our tree structure regarding the number of nodes. \\
		\emph{Best case} \\
		Any construction holding two keys in each node is best regarding the use of nodes. If the number of keys happens to be odd, one node holds a single key. This leads immediately to the lower bound:
		\[m_n =  \ceil[\Big]{\frac{n}{2}} \]
		\emph{Proof} \\
		Let's assume this bound is not tight, i.e. it exists a tree of size n keys, containing $< \ceil[\big]{\frac{n}{2}}$ nodes. Hence this tree has at most$ \ceil[\big]{\frac{n}{2}} -1 $ nodes, to which we assign n keys. The pidgeonhole principle tells us that this will lead to at least one node to which 3 keys are assigned. This contradicts the definition of our tree strucutre and is therefore impossible. \\
		\emph{Worst case} \\
		Assuming $n = 4k+1$. \\
		A tree structure degenerating to a 'chain' is the least advantagous regarding the amount of required nodes per keys. By chain we mean to say that every node has three children, but only one of them contains two keys. Therefore, there are 4 keys per 3 nodes in a 'general' level of the tree. By gerneal we mean to say that first and last level are not to be considered at this stage of the argumentation. This leads to the upper bound:
		\[M_n =  \lfloor {\frac{3n}{4}} \rfloor +1 \]
		\emph{Proof}
		Let's assume this bound is not tight, i.e. it exists a tree of size n keys, containing $> \lfloor{\frac{3n}{4}}\rfloor +1 $ nodes. Hence this tree has at least$ \lfloor {\frac{3n}{4}} \rfloor +2 = 3k + 2$ nodes, to which we assign $n=4k+1$ keys. \\
		The tree cannot grow anymore if not at least one of the nodes of a level, ????ignoring first and last level????, which comprises three nodes, has two keys. In other words, $(3k+2)\cdot \lfloor \frac{1}{3}\rfloor = k$ hold $(3k+1)\cdot \lfloor \frac{1}{3} \rfloor \cdot 2 = 2k$ keys. Followingly, there are $3k+2-k = 2k+2$ nodes and $4k+1-2k= 2k+1$ keys left. Obviously, one node will not have a key, which contradicts our definition of a node. Therefore our assumption was wrong and our bound tight.
		
	\item %(c)
	\item %(d)
	\item %(e)
	\end{enumerate}
\end{homeworkProblem}



%----------------------------------------------------------------------------------------
\end{document}
PreferencesEnglish
